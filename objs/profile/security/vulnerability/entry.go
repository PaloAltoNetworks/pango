package vulnerability

import (
	"encoding/xml"

	"github.com/PaloAltoNetworks/pango/util"
	"github.com/PaloAltoNetworks/pango/version"
)

// Entry is a normalized, version independent representation of a
// vulnerability protection profile.
type Entry struct {
	Name        string
	Description string
	Rules       []Rule
	Exceptions  []Exception
}

type Rule struct {
	Name            string
	ThreatName      string
	Cves            []string // unordered
	Host            string
	VendorIds       []string // ordered
	Severities      []string // ordered
	Category        string
	Action          string
	BlockIpTrackBy  string // PAN-OS 7.0+
	BlockIpDuration int    //PAN-OS 7.0+
	PacketCapture   string
}

type Exception struct {
	Name            string
	PacketCapture   string
	Action          string
	BlockIpTrackBy  string
	BlockIpDuration int
	TimeInterval    int
	TimeThreshold   int
	TimeTrackBy     string
	ExemptIps       []string // ordered
}

// Copy copies the information from source Entry `s` to this object.  As the
// Name field relates to the XPATH of this object, this field is not copied.
func (o *Entry) Copy(s Entry) {
	o.Description = s.Description
	if len(s.Rules) > 0 {
		o.Rules = make([]Rule, 0, len(s.Rules))
		for _, x := range s.Rules {
			r := Rule{
				Name:            x.Name,
				ThreatName:      x.ThreatName,
				Host:            x.Host,
				Category:        x.Category,
				Action:          x.Action,
				BlockIpTrackBy:  x.BlockIpTrackBy,
				BlockIpDuration: x.BlockIpDuration,
				PacketCapture:   x.PacketCapture,
			}
			if len(x.Cves) > 0 {
				r.Cves = make([]string, len(x.Cves))
				copy(r.Cves, x.Cves)
			}
			if len(x.VendorIds) > 0 {
				r.VendorIds = make([]string, len(x.VendorIds))
				copy(r.VendorIds, x.VendorIds)
			}
			if len(x.Severities) > 0 {
				r.Severities = make([]string, len(x.Severities))
				copy(r.Severities, x.Severities)
			}
			o.Rules = append(o.Rules, r)
		}
	} else {
		o.Rules = nil
	}
	if len(s.Exceptions) > 0 {
		o.Exceptions = make([]Exception, 0, len(s.Exceptions))
		for _, x := range s.Exceptions {
			e := Exception{
				Name:            x.Name,
				PacketCapture:   x.PacketCapture,
				Action:          x.Action,
				BlockIpTrackBy:  x.BlockIpTrackBy,
				BlockIpDuration: x.BlockIpDuration,
				TimeInterval:    x.TimeInterval,
				TimeThreshold:   x.TimeThreshold,
				TimeTrackBy:     x.TimeTrackBy,
			}
			if len(x.ExemptIps) > 0 {
				e.ExemptIps = make([]string, len(x.ExemptIps))
				copy(e.ExemptIps, x.ExemptIps)
			}
			o.Exceptions = append(o.Exceptions, e)
		}
	} else {
		o.Exceptions = nil
	}
}

/** Structs / functions for this namespace. **/

func (o Entry) Specify(v version.Number) (string, interface{}) {
	_, fn := versioning(v)
	return o.Name, fn(o)
}

type normalizer interface {
	Normalize() []Entry
	Names() []string
}

type container_v1 struct {
	Answer []entry_v1 `xml:"entry"`
}

func (o *container_v1) Names() []string {
	ans := make([]string, 0, len(o.Answer))
	for i := range o.Answer {
		ans = append(ans, o.Answer[i].Name)
	}

	return ans
}

func (o *container_v1) Normalize() []Entry {
	arr := make([]Entry, 0, len(o.Answer))
	for i := range o.Answer {
		arr = append(arr, o.Answer[i].normalize())
	}
	return arr
}

func (o *entry_v1) normalize() Entry {
	ans := Entry{
		Name:        o.Name,
		Description: o.Description,
	}

	if o.Rules != nil {
		list := make([]Rule, 0, len(o.Rules.Entries))
		for _, x := range o.Rules.Entries {
			item := Rule{
				Name:          x.Name,
				ThreatName:    x.ThreatName,
				Cves:          util.MemToStr(x.Cves),
				Host:          x.Host,
				VendorIds:     util.MemToStr(x.VendorIds),
				Severities:    util.MemToStr(x.Severities),
				Category:      x.Category,
				PacketCapture: x.PacketCapture,
			}

			if x.Action != nil {
				if x.Action.Default != nil {
					item.Action = ActionDefault
				} else if x.Action.Allow != nil {
					item.Action = ActionAllow
				} else if x.Action.Alert != nil {
					item.Action = ActionAlert
				} else if x.Action.Block != nil {
					item.Action = ActionBlock
				}
			}

			list = append(list, item)
		}
		ans.Rules = list
	}

	if o.Exceptions != nil {
		list := make([]Exception, 0, len(o.Exceptions.Entries))
		for _, x := range o.Exceptions.Entries {
			item := Exception{
				Name:          x.Name,
				PacketCapture: x.PacketCapture,
				ExemptIps:     util.EntToStr(x.ExemptIps),
			}

			if x.Action != nil {
				if x.Action.Default != nil {
					item.Action = ActionDefault
				} else if x.Action.Allow != nil {
					item.Action = ActionAllow
				} else if x.Action.Alert != nil {
					item.Action = ActionAlert
				} else if x.Action.Drop != nil {
					item.Action = ActionDrop
				} else if x.Action.DropAll != nil {
					item.Action = ActionDropAll
				} else if x.Action.ResetClient != nil {
					item.Action = ActionResetClient
				} else if x.Action.ResetServer != nil {
					item.Action = ActionResetServer
				} else if x.Action.ResetBoth != nil {
					item.Action = ActionResetBoth
				} else if x.Action.BlockIp != nil {
					item.Action = ActionBlockIp
					item.BlockIpTrackBy = x.Action.BlockIp.BlockIpTrackBy
					item.BlockIpDuration = x.Action.BlockIp.BlockIpDuration
				}
			}

			if x.Time != nil {
				item.TimeInterval = x.Time.TimeInterval
				item.TimeThreshold = x.Time.TimeThreshold
				item.TimeTrackBy = x.Time.TimeTrackBy
			}

			list = append(list, item)
		}
		ans.Exceptions = list
	}

	return ans
}

type entry_v1 struct {
	XMLName     xml.Name       `xml:"entry"`
	Name        string         `xml:"name,attr"`
	Description string         `xml:"description,omitempty"`
	Rules       *rules_v1      `xml:"rules"`
	Exceptions  *exceptions_v1 `xml:"threat-exception"`
}

type rules_v1 struct {
	Entries []rule_v1 `xml:"entry"`
}

type rule_v1 struct {
	Name          string           `xml:"name,attr"`
	ThreatName    string           `xml:"threat-name,omitempty"`
	Cves          *util.MemberType `xml:"cve"`
	Host          string           `xml:"host"`
	VendorIds     *util.MemberType `xml:"vendor-id"`
	Severities    *util.MemberType `xml:"severity"`
	Category      string           `xml:"category"`
	Action        *ruleAction_v1   `xml:"action"`
	PacketCapture string           `xml:"packet-capture,omitempty"`
}

type ruleAction_v1 struct {
	Default *string `xml:"default"`
	Allow   *string `xml:"allow"`
	Alert   *string `xml:"alert"`
	Block   *string `xml:"block"`
}

type exceptions_v1 struct {
	Entries []exception_v1 `xml:"entry"`
}

type exception_v1 struct {
	XMLName       xml.Name            `xml:"entry"`
	Name          string              `xml:"name,attr"`
	PacketCapture string              `xml:"packet-capture,omitempty"`
	Action        *exceptionAction_v1 `xml:"action"`
	Time          *timeAttr           `xml:"time-attribute"`
	ExemptIps     *util.EntryType     `xml:"exempt-ip"`
}

type exceptionAction_v1 struct {
	Default     *string  `xml:"default"`
	Allow       *string  `xml:"allow"`
	Alert       *string  `xml:"alert"`
	Drop        *string  `xml:"drop"`
	DropAll     *string  `xml:"drop-all-packets"`
	ResetClient *string  `xml:"reset-client"`
	ResetServer *string  `xml:"reset-server"`
	ResetBoth   *string  `xml:"reset-both"`
	BlockIp     *blockIp `xml:"block-ip"`
}

type blockIp struct {
	BlockIpTrackBy  string `xml:"track-by"`
	BlockIpDuration int    `xml:"duration"`
}

type timeAttr struct {
	TimeInterval  int    `xml:"interval"`
	TimeThreshold int    `xml:"threshold"`
	TimeTrackBy   string `xml:"track-by"`
}

func specify_v1(e Entry) interface{} {
	s := ""

	ans := entry_v1{
		Name:        e.Name,
		Description: e.Description,
	}

	if len(e.Rules) > 0 {
		list := make([]rule_v1, 0, len(e.Rules))
		for _, x := range e.Rules {
			item := rule_v1{
				Name:          x.Name,
				ThreatName:    x.ThreatName,
				Cves:          util.StrToMem(x.Cves),
				Host:          x.Host,
				VendorIds:     util.StrToMem(x.VendorIds),
				Severities:    util.StrToMem(x.Severities),
				Category:      x.Category,
				PacketCapture: x.PacketCapture,
			}

			switch x.Action {
			case ActionDefault:
				item.Action = &ruleAction_v1{
					Default: &s,
				}
			case ActionAllow:
				item.Action = &ruleAction_v1{
					Allow: &s,
				}
			case ActionAlert:
				item.Action = &ruleAction_v1{
					Alert: &s,
				}
			case ActionBlock:
				item.Action = &ruleAction_v1{
					Block: &s,
				}
			}

			list = append(list, item)
		}
		ans.Rules = &rules_v1{Entries: list}
	}

	if len(e.Exceptions) > 0 {
		list := make([]exception_v1, 0, len(e.Exceptions))
		for _, x := range e.Exceptions {
			item := exception_v1{
				Name:          x.Name,
				PacketCapture: x.PacketCapture,
				ExemptIps:     util.StrToEnt(x.ExemptIps),
			}

			switch x.Action {
			case ActionDefault:
				item.Action = &exceptionAction_v1{
					Default: &s,
				}
			case ActionAllow:
				item.Action = &exceptionAction_v1{
					Allow: &s,
				}
			case ActionAlert:
				item.Action = &exceptionAction_v1{
					Alert: &s,
				}
			case ActionDrop:
				item.Action = &exceptionAction_v1{
					Drop: &s,
				}
			case ActionDropAll:
				item.Action = &exceptionAction_v1{
					DropAll: &s,
				}
			case ActionResetClient:
				item.Action = &exceptionAction_v1{
					ResetClient: &s,
				}
			case ActionResetServer:
				item.Action = &exceptionAction_v1{
					ResetServer: &s,
				}
			case ActionResetBoth:
				item.Action = &exceptionAction_v1{
					ResetBoth: &s,
				}
			case ActionBlockIp:
				item.Action = &exceptionAction_v1{
					BlockIp: &blockIp{
						BlockIpTrackBy:  x.BlockIpTrackBy,
						BlockIpDuration: x.BlockIpDuration,
					},
				}
			}

			if x.TimeInterval != 0 || x.TimeThreshold != 0 || x.TimeTrackBy != "" {
				item.Time = &timeAttr{
					TimeInterval:  x.TimeInterval,
					TimeThreshold: x.TimeThreshold,
					TimeTrackBy:   x.TimeTrackBy,
				}
			}

			list = append(list, item)
		}
		ans.Exceptions = &exceptions_v1{Entries: list}
	}

	return ans
}

// PAN-OS 7.0.
type container_v2 struct {
	Answer []entry_v2 `xml:"entry"`
}

func (o *container_v2) Names() []string {
	ans := make([]string, 0, len(o.Answer))
	for i := range o.Answer {
		ans = append(ans, o.Answer[i].Name)
	}

	return ans
}

func (o *container_v2) Normalize() []Entry {
	arr := make([]Entry, 0, len(o.Answer))
	for i := range o.Answer {
		arr = append(arr, o.Answer[i].normalize())
	}
	return arr
}

func (o *entry_v2) normalize() Entry {
	ans := Entry{
		Name:        o.Name,
		Description: o.Description,
	}

	if o.Rules != nil {
		list := make([]Rule, 0, len(o.Rules.Entries))
		for _, x := range o.Rules.Entries {
			item := Rule{
				Name:          x.Name,
				ThreatName:    x.ThreatName,
				Cves:          util.MemToStr(x.Cves),
				Host:          x.Host,
				VendorIds:     util.MemToStr(x.VendorIds),
				Severities:    util.MemToStr(x.Severities),
				Category:      x.Category,
				PacketCapture: x.PacketCapture,
			}

			if x.Action != nil {
				if x.Action.Default != nil {
					item.Action = ActionDefault
				} else if x.Action.Allow != nil {
					item.Action = ActionAllow
				} else if x.Action.Alert != nil {
					item.Action = ActionAlert
				} else if x.Action.Drop != nil {
					item.Action = ActionDrop
				} else if x.Action.ResetClient != nil {
					item.Action = ActionResetClient
				} else if x.Action.ResetServer != nil {
					item.Action = ActionResetServer
				} else if x.Action.ResetBoth != nil {
					item.Action = ActionResetBoth
				} else if x.Action.BlockIp != nil {
					item.Action = ActionBlockIp
					item.BlockIpTrackBy = x.Action.BlockIp.BlockIpTrackBy
					item.BlockIpDuration = x.Action.BlockIp.BlockIpDuration
				}
			}

			list = append(list, item)
		}
		ans.Rules = list
	}

	if o.Exceptions != nil {
		list := make([]Exception, 0, len(o.Exceptions.Entries))
		for _, x := range o.Exceptions.Entries {
			item := Exception{
				Name:          x.Name,
				PacketCapture: x.PacketCapture,
				ExemptIps:     util.EntToStr(x.ExemptIps),
			}

			if x.Action != nil {
				if x.Action.Default != nil {
					item.Action = ActionDefault
				} else if x.Action.Allow != nil {
					item.Action = ActionAllow
				} else if x.Action.Alert != nil {
					item.Action = ActionAlert
				} else if x.Action.Drop != nil {
					item.Action = ActionDrop
				} else if x.Action.ResetClient != nil {
					item.Action = ActionResetClient
				} else if x.Action.ResetServer != nil {
					item.Action = ActionResetServer
				} else if x.Action.ResetBoth != nil {
					item.Action = ActionResetBoth
				} else if x.Action.BlockIp != nil {
					item.Action = ActionBlockIp
					item.BlockIpTrackBy = x.Action.BlockIp.BlockIpTrackBy
					item.BlockIpDuration = x.Action.BlockIp.BlockIpDuration
				}
			}

			if x.Time != nil {
				item.TimeInterval = x.Time.TimeInterval
				item.TimeThreshold = x.Time.TimeThreshold
				item.TimeTrackBy = x.Time.TimeTrackBy
			}

			list = append(list, item)
		}
		ans.Exceptions = list
	}

	return ans
}

type entry_v2 struct {
	XMLName     xml.Name       `xml:"entry"`
	Name        string         `xml:"name,attr"`
	Description string         `xml:"description,omitempty"`
	Rules       *rules_v2      `xml:"rules"`
	Exceptions  *exceptions_v2 `xml:"threat-exception"`
}

type rules_v2 struct {
	Entries []rule_v2 `xml:"entry"`
}

type rule_v2 struct {
	XMLName       xml.Name         `xml:"entry"`
	Name          string           `xml:"name,attr"`
	ThreatName    string           `xml:"threat-name,omitempty"`
	Cves          *util.MemberType `xml:"cve"`
	Host          string           `xml:"host"`
	VendorIds     *util.MemberType `xml:"vendor-id"`
	Severities    *util.MemberType `xml:"severity"`
	Category      string           `xml:"category"`
	Action        *ruleAction_v2   `xml:"action"`
	PacketCapture string           `xml:"packet-capture,omitempty"`
}

type ruleAction_v2 struct {
	Default     *string  `xml:"default"`
	Allow       *string  `xml:"allow"`
	Alert       *string  `xml:"alert"`
	Drop        *string  `xml:"drop"`
	ResetClient *string  `xml:"reset-client"`
	ResetServer *string  `xml:"reset-server"`
	ResetBoth   *string  `xml:"reset-both"`
	BlockIp     *blockIp `xml:"block-ip"`
}

type exceptions_v2 struct {
	Entries []exception_v2 `xml:"entry"`
}

type exception_v2 struct {
	XMLName       xml.Name            `xml:"entry"`
	Name          string              `xml:"name,attr"`
	PacketCapture string              `xml:"packet-capture,omitempty"`
	Action        *exceptionAction_v2 `xml:"action"`
	Time          *timeAttr           `xml:"time-attribute"`
	ExemptIps     *util.EntryType     `xml:"exempt-ip"`
}

type exceptionAction_v2 struct {
	Default     *string  `xml:"default"`
	Allow       *string  `xml:"allow"`
	Alert       *string  `xml:"alert"`
	Drop        *string  `xml:"drop"`
	ResetClient *string  `xml:"reset-client"`
	ResetServer *string  `xml:"reset-server"`
	ResetBoth   *string  `xml:"reset-both"`
	BlockIp     *blockIp `xml:"block-ip"`
}

func specify_v2(e Entry) interface{} {
	s := ""

	ans := entry_v2{
		Name:        e.Name,
		Description: e.Description,
	}

	if len(e.Rules) > 0 {
		list := make([]rule_v2, 0, len(e.Rules))
		for _, x := range e.Rules {
			item := rule_v2{
				Name:          x.Name,
				ThreatName:    x.ThreatName,
				Cves:          util.StrToMem(x.Cves),
				Host:          x.Host,
				VendorIds:     util.StrToMem(x.VendorIds),
				Severities:    util.StrToMem(x.Severities),
				Category:      x.Category,
				PacketCapture: x.PacketCapture,
			}

			switch x.Action {
			case ActionDefault:
				item.Action = &ruleAction_v2{
					Default: &s,
				}
			case ActionAllow:
				item.Action = &ruleAction_v2{
					Allow: &s,
				}
			case ActionAlert:
				item.Action = &ruleAction_v2{
					Alert: &s,
				}
			case ActionDrop:
				item.Action = &ruleAction_v2{
					Drop: &s,
				}
			case ActionResetClient:
				item.Action = &ruleAction_v2{
					ResetClient: &s,
				}
			case ActionResetServer:
				item.Action = &ruleAction_v2{
					ResetServer: &s,
				}
			case ActionResetBoth:
				item.Action = &ruleAction_v2{
					ResetBoth: &s,
				}
			case ActionBlockIp:
				item.Action = &ruleAction_v2{
					BlockIp: &blockIp{
						BlockIpTrackBy:  x.BlockIpTrackBy,
						BlockIpDuration: x.BlockIpDuration,
					},
				}
			}

			list = append(list, item)
		}
		ans.Rules = &rules_v2{Entries: list}
	}

	if len(e.Exceptions) > 0 {
		list := make([]exception_v2, 0, len(e.Exceptions))
		for _, x := range e.Exceptions {
			item := exception_v2{
				Name:          x.Name,
				PacketCapture: x.PacketCapture,
				ExemptIps:     util.StrToEnt(x.ExemptIps),
			}

			switch x.Action {
			case ActionDefault:
				item.Action = &exceptionAction_v2{
					Default: &s,
				}
			case ActionAllow:
				item.Action = &exceptionAction_v2{
					Allow: &s,
				}
			case ActionAlert:
				item.Action = &exceptionAction_v2{
					Alert: &s,
				}
			case ActionDrop:
				item.Action = &exceptionAction_v2{
					Drop: &s,
				}
			case ActionResetClient:
				item.Action = &exceptionAction_v2{
					ResetClient: &s,
				}
			case ActionResetServer:
				item.Action = &exceptionAction_v2{
					ResetServer: &s,
				}
			case ActionResetBoth:
				item.Action = &exceptionAction_v2{
					ResetBoth: &s,
				}
			case ActionBlockIp:
				item.Action = &exceptionAction_v2{
					BlockIp: &blockIp{
						BlockIpTrackBy:  x.BlockIpTrackBy,
						BlockIpDuration: x.BlockIpDuration,
					},
				}
			}

			if x.TimeInterval != 0 || x.TimeThreshold != 0 || x.TimeTrackBy != "" {
				item.Time = &timeAttr{
					TimeInterval:  x.TimeInterval,
					TimeThreshold: x.TimeThreshold,
					TimeTrackBy:   x.TimeTrackBy,
				}
			}

			list = append(list, item)
		}
		ans.Exceptions = &exceptions_v2{Entries: list}
	}

	return ans
}
