package vulnerability

import (
	"encoding/xml"
	"fmt"

	"github.com/PaloAltoNetworks/pango/filtering"
	"github.com/PaloAltoNetworks/pango/generic"
	"github.com/PaloAltoNetworks/pango/util"
	"github.com/PaloAltoNetworks/pango/version"
)

var (
	_ filtering.Fielder = &Entry{}
)

var (
	Suffix = []string{"profiles", "vulnerability"}
)

type Entry struct {
	Name                           string
	CloudInlineAnalysis            *bool
	Description                    *string
	DisableOverride                *string
	InlineExceptionEdlUrl          []string
	InlineExceptionIpAddress       []string
	MicaEngineVulnerabilityEnabled []MicaEngineVulnerabilityEnabled
	Rules                          []Rules
	ThreatException                []ThreatException

	Misc map[string][]generic.Xml
}

type MicaEngineVulnerabilityEnabled struct {
	InlinePolicyAction *string
	Name               string
}
type Rules struct {
	Action        *RulesAction
	Category      *string
	Cve           []string
	Host          *string
	Name          string
	PacketCapture *string
	Severity      []string
	ThreatName    *string
	VendorId      []string
}
type RulesAction struct {
	Alert       *RulesActionAlert
	Allow       *RulesActionAllow
	BlockIp     *RulesActionBlockIp
	Default     *RulesActionDefault
	Drop        *RulesActionDrop
	ResetBoth   *RulesActionResetBoth
	ResetClient *RulesActionResetClient
	ResetServer *RulesActionResetServer
}
type RulesActionAlert struct {
}
type RulesActionAllow struct {
}
type RulesActionBlockIp struct {
	Duration *int64
	TrackBy  *string
}
type RulesActionDefault struct {
}
type RulesActionDrop struct {
}
type RulesActionResetBoth struct {
}
type RulesActionResetClient struct {
}
type RulesActionResetServer struct {
}
type ThreatException struct {
	Action        *ThreatExceptionAction
	ExemptIp      []ThreatExceptionExemptIp
	Name          string
	PacketCapture *string
	TimeAttribute *ThreatExceptionTimeAttribute
}
type ThreatExceptionAction struct {
	Alert       *ThreatExceptionActionAlert
	Allow       *ThreatExceptionActionAllow
	BlockIp     *ThreatExceptionActionBlockIp
	Default     *ThreatExceptionActionDefault
	Drop        *ThreatExceptionActionDrop
	ResetBoth   *ThreatExceptionActionResetBoth
	ResetClient *ThreatExceptionActionResetClient
	ResetServer *ThreatExceptionActionResetServer
}
type ThreatExceptionActionAlert struct {
}
type ThreatExceptionActionAllow struct {
}
type ThreatExceptionActionBlockIp struct {
	Duration *int64
	TrackBy  *string
}
type ThreatExceptionActionDefault struct {
}
type ThreatExceptionActionDrop struct {
}
type ThreatExceptionActionResetBoth struct {
}
type ThreatExceptionActionResetClient struct {
}
type ThreatExceptionActionResetServer struct {
}
type ThreatExceptionExemptIp struct {
	Name string
}
type ThreatExceptionTimeAttribute struct {
	Interval  *int64
	Threshold *int64
	TrackBy   *string
}

type entryXmlContainer struct {
	Answer []entryXml `xml:"entry"`
}

type entryXml struct {
	XMLName                        xml.Name                            `xml:"entry"`
	Name                           string                              `xml:"name,attr"`
	CloudInlineAnalysis            *string                             `xml:"cloud-inline-analysis,omitempty"`
	Description                    *string                             `xml:"description,omitempty"`
	DisableOverride                *string                             `xml:"disable-override,omitempty"`
	InlineExceptionEdlUrl          *util.MemberType                    `xml:"inline-exception-edl-url,omitempty"`
	InlineExceptionIpAddress       *util.MemberType                    `xml:"inline-exception-ip-address,omitempty"`
	MicaEngineVulnerabilityEnabled []MicaEngineVulnerabilityEnabledXml `xml:"mica-engine-vulnerability-enabled>entry,omitempty"`
	Rules                          []RulesXml                          `xml:"rules>entry,omitempty"`
	ThreatException                []ThreatExceptionXml                `xml:"threat-exception>entry,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type MicaEngineVulnerabilityEnabledXml struct {
	InlinePolicyAction *string  `xml:"inline-policy-action,omitempty"`
	XMLName            xml.Name `xml:"entry"`
	Name               string   `xml:"name,attr"`

	Misc []generic.Xml `xml:",any"`
}
type RulesXml struct {
	Action        *RulesActionXml  `xml:"action,omitempty"`
	Category      *string          `xml:"category,omitempty"`
	Cve           *util.MemberType `xml:"cve,omitempty"`
	Host          *string          `xml:"host,omitempty"`
	XMLName       xml.Name         `xml:"entry"`
	Name          string           `xml:"name,attr"`
	PacketCapture *string          `xml:"packet-capture,omitempty"`
	Severity      *util.MemberType `xml:"severity,omitempty"`
	ThreatName    *string          `xml:"threat-name,omitempty"`
	VendorId      *util.MemberType `xml:"vendor-id,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type RulesActionXml struct {
	Alert       *RulesActionAlertXml       `xml:"alert,omitempty"`
	Allow       *RulesActionAllowXml       `xml:"allow,omitempty"`
	BlockIp     *RulesActionBlockIpXml     `xml:"block-ip,omitempty"`
	Default     *RulesActionDefaultXml     `xml:"default,omitempty"`
	Drop        *RulesActionDropXml        `xml:"drop,omitempty"`
	ResetBoth   *RulesActionResetBothXml   `xml:"reset-both,omitempty"`
	ResetClient *RulesActionResetClientXml `xml:"reset-client,omitempty"`
	ResetServer *RulesActionResetServerXml `xml:"reset-server,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type RulesActionAlertXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionAllowXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionBlockIpXml struct {
	Duration *int64  `xml:"duration,omitempty"`
	TrackBy  *string `xml:"track-by,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type RulesActionDefaultXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionDropXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionResetBothXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionResetClientXml struct {
	Misc []generic.Xml `xml:",any"`
}
type RulesActionResetServerXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionXml struct {
	Action        *ThreatExceptionActionXml        `xml:"action,omitempty"`
	ExemptIp      []ThreatExceptionExemptIpXml     `xml:"exempt-ip>entry,omitempty"`
	XMLName       xml.Name                         `xml:"entry"`
	Name          string                           `xml:"name,attr"`
	PacketCapture *string                          `xml:"packet-capture,omitempty"`
	TimeAttribute *ThreatExceptionTimeAttributeXml `xml:"time-attribute,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionXml struct {
	Alert       *ThreatExceptionActionAlertXml       `xml:"alert,omitempty"`
	Allow       *ThreatExceptionActionAllowXml       `xml:"allow,omitempty"`
	BlockIp     *ThreatExceptionActionBlockIpXml     `xml:"block-ip,omitempty"`
	Default     *ThreatExceptionActionDefaultXml     `xml:"default,omitempty"`
	Drop        *ThreatExceptionActionDropXml        `xml:"drop,omitempty"`
	ResetBoth   *ThreatExceptionActionResetBothXml   `xml:"reset-both,omitempty"`
	ResetClient *ThreatExceptionActionResetClientXml `xml:"reset-client,omitempty"`
	ResetServer *ThreatExceptionActionResetServerXml `xml:"reset-server,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionAlertXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionAllowXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionBlockIpXml struct {
	Duration *int64  `xml:"duration,omitempty"`
	TrackBy  *string `xml:"track-by,omitempty"`

	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionDefaultXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionDropXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionResetBothXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionResetClientXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionActionResetServerXml struct {
	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionExemptIpXml struct {
	XMLName xml.Name `xml:"entry"`
	Name    string   `xml:"name,attr"`

	Misc []generic.Xml `xml:",any"`
}
type ThreatExceptionTimeAttributeXml struct {
	Interval  *int64  `xml:"interval,omitempty"`
	Threshold *int64  `xml:"threshold,omitempty"`
	TrackBy   *string `xml:"track-by,omitempty"`

	Misc []generic.Xml `xml:",any"`
}

func (e *Entry) Field(v string) (any, error) {
	if v == "name" || v == "Name" {
		return e.Name, nil
	}
	if v == "cloud_inline_analysis" || v == "CloudInlineAnalysis" {
		return e.CloudInlineAnalysis, nil
	}
	if v == "description" || v == "Description" {
		return e.Description, nil
	}
	if v == "disable_override" || v == "DisableOverride" {
		return e.DisableOverride, nil
	}
	if v == "inline_exception_edl_url" || v == "InlineExceptionEdlUrl" {
		return e.InlineExceptionEdlUrl, nil
	}
	if v == "inline_exception_edl_url|LENGTH" || v == "InlineExceptionEdlUrl|LENGTH" {
		return int64(len(e.InlineExceptionEdlUrl)), nil
	}
	if v == "inline_exception_ip_address" || v == "InlineExceptionIpAddress" {
		return e.InlineExceptionIpAddress, nil
	}
	if v == "inline_exception_ip_address|LENGTH" || v == "InlineExceptionIpAddress|LENGTH" {
		return int64(len(e.InlineExceptionIpAddress)), nil
	}
	if v == "mica_engine_vulnerability_enabled" || v == "MicaEngineVulnerabilityEnabled" {
		return e.MicaEngineVulnerabilityEnabled, nil
	}
	if v == "mica_engine_vulnerability_enabled|LENGTH" || v == "MicaEngineVulnerabilityEnabled|LENGTH" {
		return int64(len(e.MicaEngineVulnerabilityEnabled)), nil
	}
	if v == "rules" || v == "Rules" {
		return e.Rules, nil
	}
	if v == "rules|LENGTH" || v == "Rules|LENGTH" {
		return int64(len(e.Rules)), nil
	}
	if v == "threat_exception" || v == "ThreatException" {
		return e.ThreatException, nil
	}
	if v == "threat_exception|LENGTH" || v == "ThreatException|LENGTH" {
		return int64(len(e.ThreatException)), nil
	}

	return nil, fmt.Errorf("unknown field")
}

func Versioning(vn version.Number) (Specifier, Normalizer, error) {

	return specifyEntry, &entryXmlContainer{}, nil
}
func specifyEntry(o *Entry) (any, error) {
	entry := entryXml{}
	entry.Name = o.Name
	entry.CloudInlineAnalysis = util.YesNo(o.CloudInlineAnalysis, nil)
	entry.Description = o.Description
	entry.DisableOverride = o.DisableOverride
	entry.InlineExceptionEdlUrl = util.StrToMem(o.InlineExceptionEdlUrl)
	entry.InlineExceptionIpAddress = util.StrToMem(o.InlineExceptionIpAddress)
	var nestedMicaEngineVulnerabilityEnabledCol []MicaEngineVulnerabilityEnabledXml
	if o.MicaEngineVulnerabilityEnabled != nil {
		nestedMicaEngineVulnerabilityEnabledCol = []MicaEngineVulnerabilityEnabledXml{}
		for _, oMicaEngineVulnerabilityEnabled := range o.MicaEngineVulnerabilityEnabled {
			nestedMicaEngineVulnerabilityEnabled := MicaEngineVulnerabilityEnabledXml{}
			if _, ok := o.Misc["MicaEngineVulnerabilityEnabled"]; ok {
				nestedMicaEngineVulnerabilityEnabled.Misc = o.Misc["MicaEngineVulnerabilityEnabled"]
			}
			if oMicaEngineVulnerabilityEnabled.InlinePolicyAction != nil {
				nestedMicaEngineVulnerabilityEnabled.InlinePolicyAction = oMicaEngineVulnerabilityEnabled.InlinePolicyAction
			}
			if oMicaEngineVulnerabilityEnabled.Name != "" {
				nestedMicaEngineVulnerabilityEnabled.Name = oMicaEngineVulnerabilityEnabled.Name
			}
			nestedMicaEngineVulnerabilityEnabledCol = append(nestedMicaEngineVulnerabilityEnabledCol, nestedMicaEngineVulnerabilityEnabled)
		}
		entry.MicaEngineVulnerabilityEnabled = nestedMicaEngineVulnerabilityEnabledCol
	}

	var nestedRulesCol []RulesXml
	if o.Rules != nil {
		nestedRulesCol = []RulesXml{}
		for _, oRules := range o.Rules {
			nestedRules := RulesXml{}
			if _, ok := o.Misc["Rules"]; ok {
				nestedRules.Misc = o.Misc["Rules"]
			}
			if oRules.Host != nil {
				nestedRules.Host = oRules.Host
			}
			if oRules.PacketCapture != nil {
				nestedRules.PacketCapture = oRules.PacketCapture
			}
			if oRules.Action != nil {
				nestedRules.Action = &RulesActionXml{}
				if _, ok := o.Misc["RulesAction"]; ok {
					nestedRules.Action.Misc = o.Misc["RulesAction"]
				}
				if oRules.Action.ResetClient != nil {
					nestedRules.Action.ResetClient = &RulesActionResetClientXml{}
					if _, ok := o.Misc["RulesActionResetClient"]; ok {
						nestedRules.Action.ResetClient.Misc = o.Misc["RulesActionResetClient"]
					}
				}
				if oRules.Action.ResetServer != nil {
					nestedRules.Action.ResetServer = &RulesActionResetServerXml{}
					if _, ok := o.Misc["RulesActionResetServer"]; ok {
						nestedRules.Action.ResetServer.Misc = o.Misc["RulesActionResetServer"]
					}
				}
				if oRules.Action.ResetBoth != nil {
					nestedRules.Action.ResetBoth = &RulesActionResetBothXml{}
					if _, ok := o.Misc["RulesActionResetBoth"]; ok {
						nestedRules.Action.ResetBoth.Misc = o.Misc["RulesActionResetBoth"]
					}
				}
				if oRules.Action.BlockIp != nil {
					nestedRules.Action.BlockIp = &RulesActionBlockIpXml{}
					if _, ok := o.Misc["RulesActionBlockIp"]; ok {
						nestedRules.Action.BlockIp.Misc = o.Misc["RulesActionBlockIp"]
					}
					if oRules.Action.BlockIp.TrackBy != nil {
						nestedRules.Action.BlockIp.TrackBy = oRules.Action.BlockIp.TrackBy
					}
					if oRules.Action.BlockIp.Duration != nil {
						nestedRules.Action.BlockIp.Duration = oRules.Action.BlockIp.Duration
					}
				}
				if oRules.Action.Default != nil {
					nestedRules.Action.Default = &RulesActionDefaultXml{}
					if _, ok := o.Misc["RulesActionDefault"]; ok {
						nestedRules.Action.Default.Misc = o.Misc["RulesActionDefault"]
					}
				}
				if oRules.Action.Allow != nil {
					nestedRules.Action.Allow = &RulesActionAllowXml{}
					if _, ok := o.Misc["RulesActionAllow"]; ok {
						nestedRules.Action.Allow.Misc = o.Misc["RulesActionAllow"]
					}
				}
				if oRules.Action.Alert != nil {
					nestedRules.Action.Alert = &RulesActionAlertXml{}
					if _, ok := o.Misc["RulesActionAlert"]; ok {
						nestedRules.Action.Alert.Misc = o.Misc["RulesActionAlert"]
					}
				}
				if oRules.Action.Drop != nil {
					nestedRules.Action.Drop = &RulesActionDropXml{}
					if _, ok := o.Misc["RulesActionDrop"]; ok {
						nestedRules.Action.Drop.Misc = o.Misc["RulesActionDrop"]
					}
				}
			}
			if oRules.ThreatName != nil {
				nestedRules.ThreatName = oRules.ThreatName
			}
			if oRules.Category != nil {
				nestedRules.Category = oRules.Category
			}
			if oRules.Cve != nil {
				nestedRules.Cve = util.StrToMem(oRules.Cve)
			}
			if oRules.VendorId != nil {
				nestedRules.VendorId = util.StrToMem(oRules.VendorId)
			}
			if oRules.Severity != nil {
				nestedRules.Severity = util.StrToMem(oRules.Severity)
			}
			if oRules.Name != "" {
				nestedRules.Name = oRules.Name
			}
			nestedRulesCol = append(nestedRulesCol, nestedRules)
		}
		entry.Rules = nestedRulesCol
	}

	var nestedThreatExceptionCol []ThreatExceptionXml
	if o.ThreatException != nil {
		nestedThreatExceptionCol = []ThreatExceptionXml{}
		for _, oThreatException := range o.ThreatException {
			nestedThreatException := ThreatExceptionXml{}
			if _, ok := o.Misc["ThreatException"]; ok {
				nestedThreatException.Misc = o.Misc["ThreatException"]
			}
			if oThreatException.ExemptIp != nil {
				nestedThreatException.ExemptIp = []ThreatExceptionExemptIpXml{}
				for _, oThreatExceptionExemptIp := range oThreatException.ExemptIp {
					nestedThreatExceptionExemptIp := ThreatExceptionExemptIpXml{}
					if _, ok := o.Misc["ThreatExceptionExemptIp"]; ok {
						nestedThreatExceptionExemptIp.Misc = o.Misc["ThreatExceptionExemptIp"]
					}
					if oThreatExceptionExemptIp.Name != "" {
						nestedThreatExceptionExemptIp.Name = oThreatExceptionExemptIp.Name
					}
					nestedThreatException.ExemptIp = append(nestedThreatException.ExemptIp, nestedThreatExceptionExemptIp)
				}
			}
			if oThreatException.Name != "" {
				nestedThreatException.Name = oThreatException.Name
			}
			if oThreatException.PacketCapture != nil {
				nestedThreatException.PacketCapture = oThreatException.PacketCapture
			}
			if oThreatException.Action != nil {
				nestedThreatException.Action = &ThreatExceptionActionXml{}
				if _, ok := o.Misc["ThreatExceptionAction"]; ok {
					nestedThreatException.Action.Misc = o.Misc["ThreatExceptionAction"]
				}
				if oThreatException.Action.ResetBoth != nil {
					nestedThreatException.Action.ResetBoth = &ThreatExceptionActionResetBothXml{}
					if _, ok := o.Misc["ThreatExceptionActionResetBoth"]; ok {
						nestedThreatException.Action.ResetBoth.Misc = o.Misc["ThreatExceptionActionResetBoth"]
					}
				}
				if oThreatException.Action.BlockIp != nil {
					nestedThreatException.Action.BlockIp = &ThreatExceptionActionBlockIpXml{}
					if _, ok := o.Misc["ThreatExceptionActionBlockIp"]; ok {
						nestedThreatException.Action.BlockIp.Misc = o.Misc["ThreatExceptionActionBlockIp"]
					}
					if oThreatException.Action.BlockIp.TrackBy != nil {
						nestedThreatException.Action.BlockIp.TrackBy = oThreatException.Action.BlockIp.TrackBy
					}
					if oThreatException.Action.BlockIp.Duration != nil {
						nestedThreatException.Action.BlockIp.Duration = oThreatException.Action.BlockIp.Duration
					}
				}
				if oThreatException.Action.Default != nil {
					nestedThreatException.Action.Default = &ThreatExceptionActionDefaultXml{}
					if _, ok := o.Misc["ThreatExceptionActionDefault"]; ok {
						nestedThreatException.Action.Default.Misc = o.Misc["ThreatExceptionActionDefault"]
					}
				}
				if oThreatException.Action.Allow != nil {
					nestedThreatException.Action.Allow = &ThreatExceptionActionAllowXml{}
					if _, ok := o.Misc["ThreatExceptionActionAllow"]; ok {
						nestedThreatException.Action.Allow.Misc = o.Misc["ThreatExceptionActionAllow"]
					}
				}
				if oThreatException.Action.Alert != nil {
					nestedThreatException.Action.Alert = &ThreatExceptionActionAlertXml{}
					if _, ok := o.Misc["ThreatExceptionActionAlert"]; ok {
						nestedThreatException.Action.Alert.Misc = o.Misc["ThreatExceptionActionAlert"]
					}
				}
				if oThreatException.Action.Drop != nil {
					nestedThreatException.Action.Drop = &ThreatExceptionActionDropXml{}
					if _, ok := o.Misc["ThreatExceptionActionDrop"]; ok {
						nestedThreatException.Action.Drop.Misc = o.Misc["ThreatExceptionActionDrop"]
					}
				}
				if oThreatException.Action.ResetClient != nil {
					nestedThreatException.Action.ResetClient = &ThreatExceptionActionResetClientXml{}
					if _, ok := o.Misc["ThreatExceptionActionResetClient"]; ok {
						nestedThreatException.Action.ResetClient.Misc = o.Misc["ThreatExceptionActionResetClient"]
					}
				}
				if oThreatException.Action.ResetServer != nil {
					nestedThreatException.Action.ResetServer = &ThreatExceptionActionResetServerXml{}
					if _, ok := o.Misc["ThreatExceptionActionResetServer"]; ok {
						nestedThreatException.Action.ResetServer.Misc = o.Misc["ThreatExceptionActionResetServer"]
					}
				}
			}
			if oThreatException.TimeAttribute != nil {
				nestedThreatException.TimeAttribute = &ThreatExceptionTimeAttributeXml{}
				if _, ok := o.Misc["ThreatExceptionTimeAttribute"]; ok {
					nestedThreatException.TimeAttribute.Misc = o.Misc["ThreatExceptionTimeAttribute"]
				}
				if oThreatException.TimeAttribute.Interval != nil {
					nestedThreatException.TimeAttribute.Interval = oThreatException.TimeAttribute.Interval
				}
				if oThreatException.TimeAttribute.Threshold != nil {
					nestedThreatException.TimeAttribute.Threshold = oThreatException.TimeAttribute.Threshold
				}
				if oThreatException.TimeAttribute.TrackBy != nil {
					nestedThreatException.TimeAttribute.TrackBy = oThreatException.TimeAttribute.TrackBy
				}
			}
			nestedThreatExceptionCol = append(nestedThreatExceptionCol, nestedThreatException)
		}
		entry.ThreatException = nestedThreatExceptionCol
	}

	entry.Misc = o.Misc["Entry"]

	return entry, nil
}

func (c *entryXmlContainer) Normalize() ([]*Entry, error) {
	entryList := make([]*Entry, 0, len(c.Answer))
	for _, o := range c.Answer {
		entry := &Entry{
			Misc: make(map[string][]generic.Xml),
		}
		entry.Name = o.Name
		entry.CloudInlineAnalysis = util.AsBool(o.CloudInlineAnalysis, nil)
		entry.Description = o.Description
		entry.DisableOverride = o.DisableOverride
		entry.InlineExceptionEdlUrl = util.MemToStr(o.InlineExceptionEdlUrl)
		entry.InlineExceptionIpAddress = util.MemToStr(o.InlineExceptionIpAddress)
		var nestedMicaEngineVulnerabilityEnabledCol []MicaEngineVulnerabilityEnabled
		if o.MicaEngineVulnerabilityEnabled != nil {
			nestedMicaEngineVulnerabilityEnabledCol = []MicaEngineVulnerabilityEnabled{}
			for _, oMicaEngineVulnerabilityEnabled := range o.MicaEngineVulnerabilityEnabled {
				nestedMicaEngineVulnerabilityEnabled := MicaEngineVulnerabilityEnabled{}
				if oMicaEngineVulnerabilityEnabled.Misc != nil {
					entry.Misc["MicaEngineVulnerabilityEnabled"] = oMicaEngineVulnerabilityEnabled.Misc
				}
				if oMicaEngineVulnerabilityEnabled.Name != "" {
					nestedMicaEngineVulnerabilityEnabled.Name = oMicaEngineVulnerabilityEnabled.Name
				}
				if oMicaEngineVulnerabilityEnabled.InlinePolicyAction != nil {
					nestedMicaEngineVulnerabilityEnabled.InlinePolicyAction = oMicaEngineVulnerabilityEnabled.InlinePolicyAction
				}
				nestedMicaEngineVulnerabilityEnabledCol = append(nestedMicaEngineVulnerabilityEnabledCol, nestedMicaEngineVulnerabilityEnabled)
			}
			entry.MicaEngineVulnerabilityEnabled = nestedMicaEngineVulnerabilityEnabledCol
		}

		var nestedRulesCol []Rules
		if o.Rules != nil {
			nestedRulesCol = []Rules{}
			for _, oRules := range o.Rules {
				nestedRules := Rules{}
				if oRules.Misc != nil {
					entry.Misc["Rules"] = oRules.Misc
				}
				if oRules.PacketCapture != nil {
					nestedRules.PacketCapture = oRules.PacketCapture
				}
				if oRules.Action != nil {
					nestedRules.Action = &RulesAction{}
					if oRules.Action.Misc != nil {
						entry.Misc["RulesAction"] = oRules.Action.Misc
					}
					if oRules.Action.ResetServer != nil {
						nestedRules.Action.ResetServer = &RulesActionResetServer{}
						if oRules.Action.ResetServer.Misc != nil {
							entry.Misc["RulesActionResetServer"] = oRules.Action.ResetServer.Misc
						}
					}
					if oRules.Action.ResetBoth != nil {
						nestedRules.Action.ResetBoth = &RulesActionResetBoth{}
						if oRules.Action.ResetBoth.Misc != nil {
							entry.Misc["RulesActionResetBoth"] = oRules.Action.ResetBoth.Misc
						}
					}
					if oRules.Action.BlockIp != nil {
						nestedRules.Action.BlockIp = &RulesActionBlockIp{}
						if oRules.Action.BlockIp.Misc != nil {
							entry.Misc["RulesActionBlockIp"] = oRules.Action.BlockIp.Misc
						}
						if oRules.Action.BlockIp.TrackBy != nil {
							nestedRules.Action.BlockIp.TrackBy = oRules.Action.BlockIp.TrackBy
						}
						if oRules.Action.BlockIp.Duration != nil {
							nestedRules.Action.BlockIp.Duration = oRules.Action.BlockIp.Duration
						}
					}
					if oRules.Action.Default != nil {
						nestedRules.Action.Default = &RulesActionDefault{}
						if oRules.Action.Default.Misc != nil {
							entry.Misc["RulesActionDefault"] = oRules.Action.Default.Misc
						}
					}
					if oRules.Action.Allow != nil {
						nestedRules.Action.Allow = &RulesActionAllow{}
						if oRules.Action.Allow.Misc != nil {
							entry.Misc["RulesActionAllow"] = oRules.Action.Allow.Misc
						}
					}
					if oRules.Action.Alert != nil {
						nestedRules.Action.Alert = &RulesActionAlert{}
						if oRules.Action.Alert.Misc != nil {
							entry.Misc["RulesActionAlert"] = oRules.Action.Alert.Misc
						}
					}
					if oRules.Action.Drop != nil {
						nestedRules.Action.Drop = &RulesActionDrop{}
						if oRules.Action.Drop.Misc != nil {
							entry.Misc["RulesActionDrop"] = oRules.Action.Drop.Misc
						}
					}
					if oRules.Action.ResetClient != nil {
						nestedRules.Action.ResetClient = &RulesActionResetClient{}
						if oRules.Action.ResetClient.Misc != nil {
							entry.Misc["RulesActionResetClient"] = oRules.Action.ResetClient.Misc
						}
					}
				}
				if oRules.Host != nil {
					nestedRules.Host = oRules.Host
				}
				if oRules.Category != nil {
					nestedRules.Category = oRules.Category
				}
				if oRules.Cve != nil {
					nestedRules.Cve = util.MemToStr(oRules.Cve)
				}
				if oRules.VendorId != nil {
					nestedRules.VendorId = util.MemToStr(oRules.VendorId)
				}
				if oRules.Severity != nil {
					nestedRules.Severity = util.MemToStr(oRules.Severity)
				}
				if oRules.Name != "" {
					nestedRules.Name = oRules.Name
				}
				if oRules.ThreatName != nil {
					nestedRules.ThreatName = oRules.ThreatName
				}
				nestedRulesCol = append(nestedRulesCol, nestedRules)
			}
			entry.Rules = nestedRulesCol
		}

		var nestedThreatExceptionCol []ThreatException
		if o.ThreatException != nil {
			nestedThreatExceptionCol = []ThreatException{}
			for _, oThreatException := range o.ThreatException {
				nestedThreatException := ThreatException{}
				if oThreatException.Misc != nil {
					entry.Misc["ThreatException"] = oThreatException.Misc
				}
				if oThreatException.ExemptIp != nil {
					nestedThreatException.ExemptIp = []ThreatExceptionExemptIp{}
					for _, oThreatExceptionExemptIp := range oThreatException.ExemptIp {
						nestedThreatExceptionExemptIp := ThreatExceptionExemptIp{}
						if oThreatExceptionExemptIp.Misc != nil {
							entry.Misc["ThreatExceptionExemptIp"] = oThreatExceptionExemptIp.Misc
						}
						if oThreatExceptionExemptIp.Name != "" {
							nestedThreatExceptionExemptIp.Name = oThreatExceptionExemptIp.Name
						}
						nestedThreatException.ExemptIp = append(nestedThreatException.ExemptIp, nestedThreatExceptionExemptIp)
					}
				}
				if oThreatException.Name != "" {
					nestedThreatException.Name = oThreatException.Name
				}
				if oThreatException.PacketCapture != nil {
					nestedThreatException.PacketCapture = oThreatException.PacketCapture
				}
				if oThreatException.Action != nil {
					nestedThreatException.Action = &ThreatExceptionAction{}
					if oThreatException.Action.Misc != nil {
						entry.Misc["ThreatExceptionAction"] = oThreatException.Action.Misc
					}
					if oThreatException.Action.BlockIp != nil {
						nestedThreatException.Action.BlockIp = &ThreatExceptionActionBlockIp{}
						if oThreatException.Action.BlockIp.Misc != nil {
							entry.Misc["ThreatExceptionActionBlockIp"] = oThreatException.Action.BlockIp.Misc
						}
						if oThreatException.Action.BlockIp.TrackBy != nil {
							nestedThreatException.Action.BlockIp.TrackBy = oThreatException.Action.BlockIp.TrackBy
						}
						if oThreatException.Action.BlockIp.Duration != nil {
							nestedThreatException.Action.BlockIp.Duration = oThreatException.Action.BlockIp.Duration
						}
					}
					if oThreatException.Action.Default != nil {
						nestedThreatException.Action.Default = &ThreatExceptionActionDefault{}
						if oThreatException.Action.Default.Misc != nil {
							entry.Misc["ThreatExceptionActionDefault"] = oThreatException.Action.Default.Misc
						}
					}
					if oThreatException.Action.Allow != nil {
						nestedThreatException.Action.Allow = &ThreatExceptionActionAllow{}
						if oThreatException.Action.Allow.Misc != nil {
							entry.Misc["ThreatExceptionActionAllow"] = oThreatException.Action.Allow.Misc
						}
					}
					if oThreatException.Action.Alert != nil {
						nestedThreatException.Action.Alert = &ThreatExceptionActionAlert{}
						if oThreatException.Action.Alert.Misc != nil {
							entry.Misc["ThreatExceptionActionAlert"] = oThreatException.Action.Alert.Misc
						}
					}
					if oThreatException.Action.Drop != nil {
						nestedThreatException.Action.Drop = &ThreatExceptionActionDrop{}
						if oThreatException.Action.Drop.Misc != nil {
							entry.Misc["ThreatExceptionActionDrop"] = oThreatException.Action.Drop.Misc
						}
					}
					if oThreatException.Action.ResetClient != nil {
						nestedThreatException.Action.ResetClient = &ThreatExceptionActionResetClient{}
						if oThreatException.Action.ResetClient.Misc != nil {
							entry.Misc["ThreatExceptionActionResetClient"] = oThreatException.Action.ResetClient.Misc
						}
					}
					if oThreatException.Action.ResetServer != nil {
						nestedThreatException.Action.ResetServer = &ThreatExceptionActionResetServer{}
						if oThreatException.Action.ResetServer.Misc != nil {
							entry.Misc["ThreatExceptionActionResetServer"] = oThreatException.Action.ResetServer.Misc
						}
					}
					if oThreatException.Action.ResetBoth != nil {
						nestedThreatException.Action.ResetBoth = &ThreatExceptionActionResetBoth{}
						if oThreatException.Action.ResetBoth.Misc != nil {
							entry.Misc["ThreatExceptionActionResetBoth"] = oThreatException.Action.ResetBoth.Misc
						}
					}
				}
				if oThreatException.TimeAttribute != nil {
					nestedThreatException.TimeAttribute = &ThreatExceptionTimeAttribute{}
					if oThreatException.TimeAttribute.Misc != nil {
						entry.Misc["ThreatExceptionTimeAttribute"] = oThreatException.TimeAttribute.Misc
					}
					if oThreatException.TimeAttribute.TrackBy != nil {
						nestedThreatException.TimeAttribute.TrackBy = oThreatException.TimeAttribute.TrackBy
					}
					if oThreatException.TimeAttribute.Interval != nil {
						nestedThreatException.TimeAttribute.Interval = oThreatException.TimeAttribute.Interval
					}
					if oThreatException.TimeAttribute.Threshold != nil {
						nestedThreatException.TimeAttribute.Threshold = oThreatException.TimeAttribute.Threshold
					}
				}
				nestedThreatExceptionCol = append(nestedThreatExceptionCol, nestedThreatException)
			}
			entry.ThreatException = nestedThreatExceptionCol
		}

		entry.Misc["Entry"] = o.Misc

		entryList = append(entryList, entry)
	}

	return entryList, nil
}

func SpecMatches(a, b *Entry) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}

	// Don't compare Name.
	if !util.BoolsMatch(a.CloudInlineAnalysis, b.CloudInlineAnalysis) {
		return false
	}
	if !util.StringsMatch(a.Description, b.Description) {
		return false
	}
	if !util.StringsMatch(a.DisableOverride, b.DisableOverride) {
		return false
	}
	if !util.OrderedListsMatch(a.InlineExceptionEdlUrl, b.InlineExceptionEdlUrl) {
		return false
	}
	if !util.OrderedListsMatch(a.InlineExceptionIpAddress, b.InlineExceptionIpAddress) {
		return false
	}
	if !matchMicaEngineVulnerabilityEnabled(a.MicaEngineVulnerabilityEnabled, b.MicaEngineVulnerabilityEnabled) {
		return false
	}
	if !matchRules(a.Rules, b.Rules) {
		return false
	}
	if !matchThreatException(a.ThreatException, b.ThreatException) {
		return false
	}

	return true
}

func matchRulesActionResetServer(a *RulesActionResetServer, b *RulesActionResetServer) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionResetBoth(a *RulesActionResetBoth, b *RulesActionResetBoth) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionBlockIp(a *RulesActionBlockIp, b *RulesActionBlockIp) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	if !util.StringsMatch(a.TrackBy, b.TrackBy) {
		return false
	}
	if !util.Ints64Match(a.Duration, b.Duration) {
		return false
	}
	return true
}
func matchRulesActionDefault(a *RulesActionDefault, b *RulesActionDefault) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionAllow(a *RulesActionAllow, b *RulesActionAllow) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionAlert(a *RulesActionAlert, b *RulesActionAlert) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionDrop(a *RulesActionDrop, b *RulesActionDrop) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesActionResetClient(a *RulesActionResetClient, b *RulesActionResetClient) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchRulesAction(a *RulesAction, b *RulesAction) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	if !matchRulesActionAllow(a.Allow, b.Allow) {
		return false
	}
	if !matchRulesActionAlert(a.Alert, b.Alert) {
		return false
	}
	if !matchRulesActionDrop(a.Drop, b.Drop) {
		return false
	}
	if !matchRulesActionResetClient(a.ResetClient, b.ResetClient) {
		return false
	}
	if !matchRulesActionResetServer(a.ResetServer, b.ResetServer) {
		return false
	}
	if !matchRulesActionResetBoth(a.ResetBoth, b.ResetBoth) {
		return false
	}
	if !matchRulesActionBlockIp(a.BlockIp, b.BlockIp) {
		return false
	}
	if !matchRulesActionDefault(a.Default, b.Default) {
		return false
	}
	return true
}
func matchRules(a []Rules, b []Rules) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	for _, a := range a {
		for _, b := range b {
			if !util.StringsMatch(a.Host, b.Host) {
				return false
			}
			if !util.StringsMatch(a.PacketCapture, b.PacketCapture) {
				return false
			}
			if !matchRulesAction(a.Action, b.Action) {
				return false
			}
			if !util.StringsMatch(a.ThreatName, b.ThreatName) {
				return false
			}
			if !util.StringsMatch(a.Category, b.Category) {
				return false
			}
			if !util.OrderedListsMatch(a.Cve, b.Cve) {
				return false
			}
			if !util.OrderedListsMatch(a.VendorId, b.VendorId) {
				return false
			}
			if !util.OrderedListsMatch(a.Severity, b.Severity) {
				return false
			}
			if !util.StringsEqual(a.Name, b.Name) {
				return false
			}
		}
	}
	return true
}
func matchThreatExceptionActionDefault(a *ThreatExceptionActionDefault, b *ThreatExceptionActionDefault) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionAllow(a *ThreatExceptionActionAllow, b *ThreatExceptionActionAllow) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionAlert(a *ThreatExceptionActionAlert, b *ThreatExceptionActionAlert) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionDrop(a *ThreatExceptionActionDrop, b *ThreatExceptionActionDrop) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionResetClient(a *ThreatExceptionActionResetClient, b *ThreatExceptionActionResetClient) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionResetServer(a *ThreatExceptionActionResetServer, b *ThreatExceptionActionResetServer) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionResetBoth(a *ThreatExceptionActionResetBoth, b *ThreatExceptionActionResetBoth) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	return true
}
func matchThreatExceptionActionBlockIp(a *ThreatExceptionActionBlockIp, b *ThreatExceptionActionBlockIp) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	if !util.StringsMatch(a.TrackBy, b.TrackBy) {
		return false
	}
	if !util.Ints64Match(a.Duration, b.Duration) {
		return false
	}
	return true
}
func matchThreatExceptionAction(a *ThreatExceptionAction, b *ThreatExceptionAction) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	if !matchThreatExceptionActionResetBoth(a.ResetBoth, b.ResetBoth) {
		return false
	}
	if !matchThreatExceptionActionBlockIp(a.BlockIp, b.BlockIp) {
		return false
	}
	if !matchThreatExceptionActionDefault(a.Default, b.Default) {
		return false
	}
	if !matchThreatExceptionActionAllow(a.Allow, b.Allow) {
		return false
	}
	if !matchThreatExceptionActionAlert(a.Alert, b.Alert) {
		return false
	}
	if !matchThreatExceptionActionDrop(a.Drop, b.Drop) {
		return false
	}
	if !matchThreatExceptionActionResetClient(a.ResetClient, b.ResetClient) {
		return false
	}
	if !matchThreatExceptionActionResetServer(a.ResetServer, b.ResetServer) {
		return false
	}
	return true
}
func matchThreatExceptionTimeAttribute(a *ThreatExceptionTimeAttribute, b *ThreatExceptionTimeAttribute) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	if !util.StringsMatch(a.TrackBy, b.TrackBy) {
		return false
	}
	if !util.Ints64Match(a.Interval, b.Interval) {
		return false
	}
	if !util.Ints64Match(a.Threshold, b.Threshold) {
		return false
	}
	return true
}
func matchThreatExceptionExemptIp(a []ThreatExceptionExemptIp, b []ThreatExceptionExemptIp) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	for _, a := range a {
		for _, b := range b {
			if !util.StringsEqual(a.Name, b.Name) {
				return false
			}
		}
	}
	return true
}
func matchThreatException(a []ThreatException, b []ThreatException) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	for _, a := range a {
		for _, b := range b {
			if !matchThreatExceptionExemptIp(a.ExemptIp, b.ExemptIp) {
				return false
			}
			if !util.StringsEqual(a.Name, b.Name) {
				return false
			}
			if !util.StringsMatch(a.PacketCapture, b.PacketCapture) {
				return false
			}
			if !matchThreatExceptionAction(a.Action, b.Action) {
				return false
			}
			if !matchThreatExceptionTimeAttribute(a.TimeAttribute, b.TimeAttribute) {
				return false
			}
		}
	}
	return true
}
func matchMicaEngineVulnerabilityEnabled(a []MicaEngineVulnerabilityEnabled, b []MicaEngineVulnerabilityEnabled) bool {
	if a == nil && b != nil || a != nil && b == nil {
		return false
	} else if a == nil && b == nil {
		return true
	}
	for _, a := range a {
		for _, b := range b {
			if !util.StringsMatch(a.InlinePolicyAction, b.InlinePolicyAction) {
				return false
			}
			if !util.StringsEqual(a.Name, b.Name) {
				return false
			}
		}
	}
	return true
}

func (o *Entry) EntryName() string {
	return o.Name
}

func (o *Entry) SetEntryName(name string) {
	o.Name = name
}
